<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Interactive Map</title>
  <style>
    #map { height: 100vh; width: 100%; }
    #filters {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      z-index: 5;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    select { margin: 5px 0; width: 150px; }

    .gm-ui-hover-effect {
      display: none !important;
    }
  </style>
</head>
<body>
<div id="filters">
  <label for="countryFilter">Country:</label>
  <select id="countryFilter"><option value="all">All</option></select><br>
  <label for="tabletFilter">Tablet:</label>
  <select id="tabletFilter"><option value="all">All</option></select><br>
  <label for="yearFilter">Year:</label>
  <select id="yearFilter"><option value="all">All</option></select><br>
  <label><input type="checkbox" id="showRed" checked> Show Error Markers</label><br>
  <label><input type="checkbox" id="showInfo" checked> Show Marker Info</label>
</div>

<div id="map"></div>

<script src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js"></script>
<script>
const { MarkerClusterer, SuperClusterAlgorithm } = window.markerClusterer;
let map, allData = [];
let greenCluster = null, redCluster = null;
let greenMarkerObjs = [], redMarkerObjs = [];
let greenClusterMarkerObjs = [], redClusterMarkerObjs = [];
let showRed = true;
let showInfo = true;

async function loadData() {
  const res = await fetch("map_data_IND-Github.json");
  allData = await res.json();
  populateFilters();
  drawMarkers();
  addToggleListener();
}

function initMap() {
  map = new google.maps.Map(document.getElementById("map"), {
    center: { lat: -25.0, lng: 133.0 },
    zoom: 4
  });
  loadData();
  document.getElementById("countryFilter").addEventListener("change", drawMarkers);
  document.getElementById("tabletFilter").addEventListener("change", drawMarkers);
  document.getElementById("yearFilter").addEventListener("change", drawMarkers);
}

function addToggleListener() {
  document.getElementById("showRed").addEventListener("change", e => {
    showRed = e.target.checked;
    drawMarkers();
  });

  document.getElementById("showInfo").addEventListener("change", e => {
    showInfo = e.target.checked;
    drawMarkers();
  });
}

function populateFilters() {
  const countries = [...new Set(allData.map(d => d.country))].sort();
  const tablets = [...new Set(allData.map(d => d.tablet))].sort();
  const years = [...new Set(allData.map(d => d.year))].sort();

  const countrySelect = document.getElementById("countryFilter");
  countries.forEach(c => countrySelect.add(new Option(c, c)));
  const tabletSelect = document.getElementById("tabletFilter");
  tablets.forEach(t => tabletSelect.add(new Option(t, t)));
  const yearSelect = document.getElementById("yearFilter");
  years.forEach(y => yearSelect.add(new Option(y, y)));
}

// helper to safely remove & clear arrays of markers
function removeAndClear(arr) {
  if (!arr || arr.length === 0) return;
  arr.forEach(m => {
    try { google.maps.event.clearInstanceListeners(m); } catch (e) {}
    try { m.setMap(null); } catch (e) {}
  });
  arr.length = 0;
}

function clearPrevious() {
  // clear clusterers first (defensive)
  if (greenCluster) {
    try { greenCluster.clearMarkers(); } catch (e) { /* ignore */ }
    greenCluster = null;
  }
  if (redCluster) {
    try { redCluster.clearMarkers(); } catch (e) { /* ignore */ }
    redCluster = null;
  }

  // remove any cluster-icons created by the renderer (these are the overlay "7" markers)
  removeAndClear(greenClusterMarkerObjs);
  removeAndClear(redClusterMarkerObjs);

  // remove raw individual markers
  removeAndClear(greenMarkerObjs);
  removeAndClear(redMarkerObjs);
}

function createMarker(d) {
  const m = new google.maps.Marker({
    position: { lat: d.lat, lng: d.lon },
    icon: {
      path: google.maps.SymbolPath.CIRCLE,
      scale: 17,
      fillColor: d.color,
      fillOpacity: 0.7,
      strokeColor: "#000",
      strokeWeight: 1
    },
    label: {
      text: "1",
      color: "white",
      fontSize: "10px",
      fontWeight: "bold"
    }
  });
  // attach meta
  m._country = d.country;
  return m;
}

function drawMarkers() {
  // full cleanup of everything created previously
  clearPrevious();

  const countryFilter = document.getElementById("countryFilter").value;
  const tabletFilter = document.getElementById("tabletFilter").value;
  const yearFilter = document.getElementById("yearFilter").value;

  const filtered = allData.filter(d =>
    (countryFilter === "all" || d.country === countryFilter) &&
    (tabletFilter === "all" || d.tablet === tabletFilter) &&
    (yearFilter === "all" || d.year === yearFilter)
  );

  // create raw markers and keep references
  const greenMarkers = filtered.filter(d => !d.failed).map(d => {
    const mm = createMarker(d);
    greenMarkerObjs.push(mm);
    return mm;
  });

  const redMarkers = showRed ? filtered.filter(d => d.failed).map(d => {
    const mm = createMarker(d);
    redMarkerObjs.push(mm);
    return mm;
  }) : [];

  const algorithmSettings = new SuperClusterAlgorithm({
    radius: 100,
    minPoints: 1,
    maxZoom: 30
  });

  // create / reuse green cluster
  if (greenMarkers.length > 0) {
    greenCluster = new MarkerClusterer({
      map,
      markers: greenMarkers,
      algorithm: algorithmSettings,
      renderer: makeRenderer("#41ab5d", "#000", false)
    });
  }

  // create red cluster only when requested
  if (showRed && redMarkers.length > 0) {
    redCluster = new MarkerClusterer({
      map,
      markers: redMarkers,
      algorithm: algorithmSettings,
      renderer: makeRenderer("#FF0000", "#000", true)
    });
  } else {
    // defensive removal in case something remained
    removeAndClear(redMarkerObjs);
    if (redCluster) {
      try { redCluster.clearMarkers(); } catch (e) {}
      redCluster = null;
    }
    removeAndClear(redClusterMarkerObjs);
  }
}

// renderer now captures the cluster-marker it creates so we can explicitly remove it later
function makeRenderer(color, stroke, isRedCluster = false) {
  const clusterArr = isRedCluster ? redClusterMarkerObjs : greenClusterMarkerObjs;
  return {
    render: ({ count, position, markers }) => {
      const clusterMarker = new google.maps.Marker({
        position,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 17,
          fillColor: color,
          fillOpacity: 0.7,
          strokeColor: stroke,
          strokeWeight: 1
        },
        label: {
          text: String(count),
          color: "white",
          fontSize: "12px",
          fontWeight: "bold"
        }
      });

      // store cluster-icons so we can remove them explicitly later
      clusterArr.push(clusterMarker);

      if (isRedCluster && showRed && showInfo) {
        const infoWindow = new google.maps.InfoWindow();
        clusterMarker.addListener("mouseover", () => {
          const countries = [...new Set(markers.map(m => m._country))];
          infoWindow.setContent(`Error data for ${countries.join(", ")}`);
          infoWindow.open({ map, anchor: clusterMarker });
        });
        clusterMarker.addListener("mouseout", () => infoWindow.close());
      }

      return clusterMarker;
    }
  };
}

window.initMap = initMap;
</script>

<script async defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAHX58A6JxigzMs0tFNEevb1kAcq9px_J4&callback=initMap">
</script>
</body>
</html>
